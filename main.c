#include <curses.h>
#include <errno.h>
#include <getopt.h>
#include <gpgme.h>
#include <locale.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <sys/stat.h>

#include "security/buffers.c"
#include "ui/c2fa.c"

#include "common.h"


#define LOG(fmt, ...) do { \
	if (verbose) { \
	    fprintf(stderr, "[LOG] " fmt "\n", __VA_ARGS__); \
	} \
} while (0)
#define PROG "C2FA"
#define VERSION_MAJOR "0"
#define VERSION_MINOR "4"
#define VERSION_CYCLE "prealpha"  
#define VERSION VERSION_MAJOR "." VERSION_MINOR "-" VERSION_CYCLE
#define PATH_MAX 4096 //obtained with getconf
#define USER_MAX 32

//Function 
void secure_wipe_otp(struct OTP *otp) {
    // Securely wipe and free the secret
    if (otp->secret != NULL) {
        size_t secret_len = strlen(otp->secret);
        volatile char *p = (volatile char *)otp->secret;
        for (size_t i = 0; i < secret_len; i++) {
            p[i] = '\0';
        }
        free(otp->secret);
        otp->secret = NULL;
    }

    // Free the filename (wipe if it contains sensitive info)
    if (otp->filename != NULL) {
        free(otp->filename);
        otp->filename = NULL;
    }

    // Securely wipe the entire struct
    volatile struct OTP *vol_otp = (volatile struct OTP *)otp;
    vol_otp->digits = 0;
    vol_otp->algo = 0;
    vol_otp->period_short = 0;
    vol_otp->locked = 0;
}

static int verbose = 0;
static int locked = 1;
char filepath[PATH_MAX] = {0};
char username[USER_MAX] = {0};
struct OTP OTPs[MAX_OTP] = {0};

gpgme_ctx_t ctx;
gpgme_error_t err;
gpgme_key_t key;

cotp_error_t *cotp_err;
int ui_err;
int y_index = 1;
int page = 1;
int occupied_otps = 0;
int current_otp= -1;

void print_help() {
	fprintf(stdout, "\n%s - %s usage:\n",PROG,VERSION);
	fprintf(stdout, "\t--verbose\tVerbosity set\n");
	fprintf(stdout, "\t--version\tPrints version and exit\n");
	fprintf(stdout, "\t--filepath\tSets filepath, example: foo/bar\n");
	fprintf(stdout, "\t--user\tSets user variable if $USER is not available, example: --user janedoe\n");
}

int print_cotp_error(cotp_error_t error, const char *context) {
	switch(error) {
		case NO_ERROR:
			return 1;	
			break;
		case VALID:
			return 2;
			break;
		case WCRYPT_VERSION_MISMATCH:
			ui_show_error("get_totp failed on ui_show_totp fn: Wcrypt version mismatch");
			return 0;
		case INVALID_B32_INPUT:
			ui_show_error("get_totp failed on ui_show_totp fn: Invalid Base32 input");
			return 0;
		case INVALID_ALGO:
			ui_show_error("get_totp failed on ui_show_totp fn: Invalid algorithm specified");
			return 0;
		case INVALID_DIGITS:
			ui_show_error("get_totp failed on ui_show_totp fn: Invalid number of digits requested");
			return 0;
		case INVALID_PERIOD:
			ui_show_error("get_totp failed on ui_show_totp fn: Invalid period specified");
			return 0;
		case MEMORY_ALLOCATION_ERROR:
			ui_show_error("get_totp failed on ui_show_totp fn: Memory allocation failed");
			return 0;
		case INVALID_USER_INPUT:
			ui_show_error("get_totp failed on ui_show_totp fn: Invalid user input");
			return 0;
		case EMPTY_STRING:
			ui_show_error("get_totp failed on ui_show_totp fn: Empty string provided where not allowed");
			return 0;
		case MISSING_LEADING_ZERO:
			ui_show_error("get_totp failed on ui_show_totp fn: Missing leading zero in input");
			return 0;
		case INVALID_COUNTER:
			ui_show_error("get_totp failed on ui_show_totp fn: Invalid counter value");
			return 0;
		case WHMAC_ERROR:
			ui_show_error("get_totp failed on ui_show_totp fn: HMAC error occurred");
			return 0;
		default:
			ui_show_error("get_totp failed on ui_show_totp fn: Unknown error code");
			return 0;
	}
}

//This was generated by deepseek, I am a noob coder in C, still learning
char* my_strdup(const char *s) {
    if (s == NULL)  return NULL;
    size_t len = strlen(s) + 1;   
    char *dup = malloc(len);
    if (dup != NULL) memcpy(dup, s, len);
    return dup;
}


//This was DeepSeek assisted, common.h also has been assisted



//This was strict copy paste from a GPGME official site
void init_gpgme (void) {
  /* Initialize the locale environment.  */
  setlocale (LC_ALL, "");
  gpgme_check_version (NULL);
  gpgme_set_locale (NULL, LC_CTYPE, setlocale (LC_CTYPE, NULL));
#ifdef LC_MESSAGES
  gpgme_set_locale (NULL, LC_MESSAGES, setlocale (LC_MESSAGES, NULL));
#endif
}

//This was copypaste from Deepseek, i understand what everything does, I am a bit lazy
int ensure_directory_exists(const char *path, mode_t mode) {
	struct stat statbuf;
	if (stat(path, &statbuf) == 0) {
		if (S_ISDIR(statbuf.st_mode)) {
			return 0;
		} else {
			return -1;
		}
	}
	if (mkdir(path, mode) == 0) return 1; 
	if (errno == EEXIST) return 0;
	return -1; 
}

void redraw_info(WINDOW *win_info) {
	int row = 1;
	box(win_info,0,0);
	set_title(win_info, "Information");
	mvwaddstr(win_info,row,2,"E-mail: ");
	mvwaddstr(win_info,row,10,key->uids->email);
	row++;
	mvwaddstr(win_info,row,2,"Fingerprint: ");
	mvwaddstr(win_info,row,15,key->fpr);
	row++;
	if (verbose) {
		const char *verbose_str = " VERBOSE MODE ";
		int string_length = strlen(verbose_str);
		int MAX_DASHES = (getmaxx(win_info)-string_length)/2;
		for (int i = 1;i<MAX_DASHES;i++) {
			mvwaddstr(win_info,row,i,"-");
		}
		mvwaddstr(win_info,row,MAX_DASHES,verbose_str);
		for (int i = MAX_DASHES+string_length;i<getmaxx(win_info)-1;i++) {
			mvwaddstr(win_info,row,i,"-");
		}
		row++;
		char y_index_str[sizeof(int)];
		snprintf(y_index_str,sizeof(int),"%d",y_index);
		mvwaddstr(win_info,row,2, "y_index: ");
		mvwaddstr(win_info,row,12, "  ");
		mvwaddstr(win_info,row,12, y_index_str);
		row++;
		char page_str[sizeof(int)];
		snprintf(page_str,sizeof(int),"%d",page);
		mvwaddstr(win_info,row,2, "page: ");
		mvwaddstr(win_info,row,9, "  ");
		mvwaddstr(win_info,row,9, page_str);
		row++;
		char current_otp_str[sizeof(int)];
		snprintf(current_otp_str,sizeof(int),"%d",current_otp);
		mvwaddstr(win_info,row,2, "current otp: ");
		mvwaddstr(win_info,row,14, "  ");
		mvwaddstr(win_info,row,14, current_otp_str);
		row++;
		char occupied_otps_str[sizeof(int)];
		snprintf(occupied_otps_str,sizeof(int),"%d",occupied_otps);
		mvwaddstr(win_info,row,2, "occupied OTPs: ");
		mvwaddstr(win_info,row,16, "  ");
		mvwaddstr(win_info,row,16, occupied_otps_str);

		if (occupied_otps >= 0) {
			row++;
			row++;
			mvwaddstr(win_info,row,2, "Current OTP Info. ");
			row++;

			mvwaddstr(win_info,row,2,"                                                   ");
			mvwaddstr(win_info,row,2,"Filename: ");
			mvwaddstr(win_info,row,11, OTPs[current_otp].filename);
			row++;
			mvwaddstr(win_info,row,2,"                                                   ");
			mvwaddstr(win_info,row,2,"Secret: ");
			mvwaddstr(win_info,row,9, OTPs[current_otp].secret);
			row++;
			mvwaddstr(win_info,row,2,"                                                   ");
			mvwaddstr(win_info,row,2,"Algo: ");
			mvwaddstr(win_info,row,7, OTPs[current_otp].algo == 2 ? "SHA-512" : OTPs[current_otp].algo ? "SHA-256" : "SHA-1");
		}
	}
}

void process_ui_input(int ch, WINDOW *win_totp, WINDOW *win_info, int stdscr_lines, int stdscr_cols) {
	switch (ch) {
		
		case 10:  // Enter key
		case 'l':
		case KEY_RIGHT:
			if (occupied_otps >= 0 && current_otp >= 0) {
			OTPs[current_otp].locked = !OTPs[current_otp].locked; // Toggle lock state
			}
			break;
		case 'k':
		case KEY_UP: {
			if (current_otp > 0) {
			current_otp--;
			y_index = current_otp + 1;
			}
			break;
		}
		case 'j':
		case KEY_DOWN: {
			if (current_otp < occupied_otps - 1) {
			current_otp++;
			y_index = current_otp + 1;
			}
			break;
		}
		case 'a': {
			if (!setup_ui_new_secret(occupied_otps, OTPs)) {
			ui_show_error("Error adding new secret");
			} else {
			occupied_otps += 1;
			current_otp = occupied_otps - 1;
			y_index = current_otp + 1;
			}
			break;
		} case 'd':
			if (occupied_otps > 0) {
				secure_wipe_otp(&OTPs[current_otp]);
				current_otp = current_otp-1 == -1 ? -1 : current_otp-1;
				occupied_otps--;
			}
			break;
		default:
			break;

	}
	werase(win_totp);
	redraw_info(win_info);
	box(win_totp, 0, 0);
	set_title(win_totp, "OTP List");
	if (occupied_otps >= 0) ui_draw_otps(OTPs, current_otp, page, occupied_otps, win_totp);
	wrefresh(win_totp);
	wrefresh(win_info);
}


int main(int argc, char *argv[]) {
	int cols,lines;

	init_gpgme();
	err = gpgme_new(&ctx);
	if (err) {
	    fprintf(stderr, "Error setting context: %s\n", gpgme_strerror(err));
	    exit(1);
	}
	err = gpgme_get_key(ctx, "foobar@test.com", &key, 0);
	if (err) {
	    fprintf(stderr, "Key not found: %s\n", gpgme_strerror(err));
	    exit(1);
	}
	
	strncpy(username, getenv("USER"), USER_MAX-1);
	if (username[0] != '\0') username[USER_MAX-1] = '\0';

	int c;
	int option_index = 0; 

	while (1) {
		static struct option long_options[] = {
			{"verbose",   no_argument,       &verbose, 1},
			{"version",   no_argument,       0,        'V'},
			{"user",   no_argument,       0,        'U'},
			{"filepath",  no_argument, 0,        'f'},
			{"gpg-id",  required_argument, 0,        'i'},
			{0, 0, 0, 0}
		};
		c = getopt_long(argc, argv, "", long_options, &option_index);
		if (c == -1) break;
		switch (c) {
			case 0:
				break;
			case 'V':
				printf("%s -- VERSION %s\n", PROG, VERSION);
				exit(0);
				break;
			case 'f':
				if (optarg == NULL) {
					fprintf(stderr, "Invalid argument");
				        print_help();
					exit(EXIT_FAILURE);
				}
				if (!is_safe_path(optarg)) {
					fprintf(stderr, "Invalid path: %s\n", optarg);
				        print_help();
					exit(EXIT_FAILURE);
				}
				size_t input_len = strlen(optarg);
				if (input_len == 0 || input_len >= PATH_MAX - 1) { 
					fprintf(stderr, "Invalid path length\n");
					print_help();
					exit(EXIT_FAILURE);
				}
				strncpy(filepath, optarg, sizeof(filepath) - 1);
				filepath[sizeof(filepath) - 1] = '\0';
				break;
			case 'i':
				strncpy(filepath,optarg,sizeof(filepath)-1);
				break;
			case 'U':
				if (!(is_buffer_alphanum(optarg))) exit(EXIT_FAILURE);
				if (username[0] != '\0') fprintf(stderr, "WARNING: Overwriting current value of username %s with %.*s\n", username, USER_MAX - 1, optarg);
				strncpy(
					username,
					optarg,
					USER_MAX- 1
				);
				break;
			case '?':
				print_help();
				exit(EXIT_FAILURE);
				break;
			default:
				abort();
		}
	}

	
	if (username[0] == '\0') {
		fprintf(
			stderr,
			"Error: Could not get USER environment variable\n"
		);
		print_help();
		return 1;
	}

	
	if (filepath[0] == '\0') {
		size_t needed_size = snprintf(NULL, 0, "/home/%s/%s", username, SECRETS_DIR) +1;
		snprintf(filepath, PATH_MAX,"/home/%s/%s",username,SECRETS_DIR);
	}
	
	cotp_error_t tcotp_err = NO_ERROR;
	LOG("FILEPATH: %s\n", filepath);
	LOG("USER: %s\n", username);
	LOG("Press any key to %s\n", "continue");
	
	//Init curses, this must be done at the end, so I can see the debug messages.
	initscr();
	start_color();
	noecho();
	clear();

	getmaxyx(stdscr, cols, lines);	
	WINDOW *win_totp = newwin(cols, (lines/2-1),0,0);
	WINDOW *win_info = newwin((cols/2)-1, (lines/2)-1,0,lines/2);

	keypad(stdscr, TRUE);
	keypad(win_totp, TRUE);
	keypad(win_info, TRUE);
	box(win_totp,0,0);
	set_title(win_totp, "OTP List");
	redraw_info(win_info);
	wrefresh(stdscr);
	wrefresh(win_totp);
	wrefresh(win_info);
	int ch;
	while ((ch = getch()) != 'q') {
		process_ui_input(ch,win_totp, win_info, lines,cols);
	}
	delwin(win_totp);
	delwin(win_info);
	delwin(stdscr);
	endwin();


	gpgme_release(ctx);
	return 0;
}
